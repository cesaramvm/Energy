LINECHART APPLICATION

                public class LineChartSample extends Application {

                    private static ArrayList<Double> data;
                    private static String mseChartTitle;

                    @Override
                    public void start(Stage stage) {
                        stage.setTitle("Line Chart");
                        //defining the axes
                        NumberAxis xAxis = new NumberAxis();
                        NumberAxis yAxis = new NumberAxis();
                        xAxis.setLabel("Epochs");
                        yAxis.setLabel("MSE");
                        //creating the chart
                        LineChart<Number, Number> lineChart = new LineChart<>(xAxis, yAxis);

                        lineChart.setTitle("MSE Chart for " + mseChartTitle);
                        //defining a series
                        XYChart.Series series = new XYChart.Series();
                        series.setName("My portfolio");
                        //populating the series with data
                        for (int i = 0; i < data.size(); i++) {
                            Double d = data.get(i);
                            series.getData().add(new XYChart.Data(i, d));
                        }

                        Scene scene = new Scene(lineChart, 1000, 600);
                        lineChart.getData().add(series);

                        stage.setScene(scene);
                        stage.show();
                    }

                    public void execute(ArrayList<Double> incomingData, String chartTitle) {
                        data = incomingData;
                        mseChartTitle = chartTitle;
                        launch();
                    }
                }

DRAWGRAPH (Grafico completamente)
                        package energytfg;

                     import java.awt.BasicStroke;
                     import java.awt.Color;
                     import java.awt.Dimension;
                     import java.awt.FontMetrics;
                     import java.awt.Graphics;
                     import java.awt.Graphics2D;
                     import java.awt.Point;
                     import java.awt.RenderingHints;
                     import java.awt.Stroke;
                     import java.util.ArrayList;
                     import java.util.List;
                     import javax.swing.JFrame;
                     import javax.swing.JPanel;

                     public class DrawGraph extends JPanel {

                         private final int width = 800;
                         private final int heigth = 400;
                         private final int padding = 25;
                         private final int labelPadding = 25;
                         private final Color lineColor = new Color(44, 102, 230, 180);
                         private final Color pointColor = new Color(100, 100, 100, 180);
                         private final Color gridColor = new Color(200, 200, 200, 200);
                         private static final Stroke GRAPH_STROKE = new BasicStroke(2f);
                         private final int pointWidth = 4;
                         private final int numberYDivisions = 10;
                         private List<Double> scores;

                         public DrawGraph(List<Double> scores) {
                             this.scores = scores;
                         }

                         @Override
                         protected void paintComponent(Graphics g) {
                             super.paintComponent(g);
                             Graphics2D g2 = (Graphics2D) g;
                             g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                             double xScale = ((double) getWidth() - (2 * padding) - labelPadding) / (scores.size() - 1);
                             double yScale = ((double) getHeight() - 2 * padding - labelPadding) / (getMaxScore() - getMinScore());

                             List<Point> graphPoints = new ArrayList<>();
                             for (int i = 0; i < scores.size(); i++) {
                                 int x1 = (int) (i * xScale + padding + labelPadding);
                                 int y1 = (int) ((getMaxScore() - scores.get(i)) * yScale + padding);
                                 graphPoints.add(new Point(x1, y1));
                             }

                             // draw white background
                             g2.setColor(Color.WHITE);
                             g2.fillRect(padding + labelPadding, padding, getWidth() - (2 * padding) - labelPadding, getHeight() - 2 * padding - labelPadding);
                             g2.setColor(Color.BLACK);

                             // create hatch marks and grid lines for y axis.
                             for (int i = 0; i < numberYDivisions + 1; i++) {
                                 int x0 = padding + labelPadding;
                                 int x1 = pointWidth + padding + labelPadding;
                                 int y0 = getHeight() - ((i * (getHeight() - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
                                 int y1 = y0;
                                 if (scores.size() > 0) {
                                     g2.setColor(gridColor);
                                     g2.drawLine(padding + labelPadding + 1 + pointWidth, y0, getWidth() - padding, y1);
                                     g2.setColor(Color.BLACK);
                                     String yLabel = ((int) ((getMinScore() + (getMaxScore() - getMinScore()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
                                     FontMetrics metrics = g2.getFontMetrics();
                                     int labelWidth = metrics.stringWidth(yLabel);
                                     g2.drawString(yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight() / 2) - 3);
                                 }
                                 g2.drawLine(x0, y0, x1, y1);
                             }

                             // and for x axis
                             for (int i = 0; i < scores.size(); i++) {
                                 if (scores.size() > 1) {
                                     int x0 = i * (getWidth() - padding * 2 - labelPadding) / (scores.size() - 1) + padding + labelPadding;
                                     int x1 = x0;
                                     int y0 = getHeight() - padding - labelPadding;
                                     int y1 = y0 - pointWidth;
                                     if ((i % ((int) ((scores.size() / 20.0)) + 1)) == 0) {
                                         g2.setColor(gridColor);
                                         g2.drawLine(x0, getHeight() - padding - labelPadding - 1 - pointWidth, x1, padding);
                                         g2.setColor(Color.BLACK);
                                         String xLabel = i + "";
                                         FontMetrics metrics = g2.getFontMetrics();
                                         int labelWidth = metrics.stringWidth(xLabel);
                                         g2.drawString(xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight() + 3);
                                     }
                                     g2.drawLine(x0, y0, x1, y1);
                                 }
                             }

                             // create x and y axes 
                             g2.drawLine(padding + labelPadding, getHeight() - padding - labelPadding, padding + labelPadding, padding);
                             g2.drawLine(padding + labelPadding, getHeight() - padding - labelPadding, getWidth() - padding, getHeight() - padding - labelPadding);

                             Stroke oldStroke = g2.getStroke();
                             g2.setColor(lineColor);
                             g2.setStroke(GRAPH_STROKE);
                             for (int i = 0; i < graphPoints.size() - 1; i++) {
                                 int x1 = graphPoints.get(i).x;
                                 int y1 = graphPoints.get(i).y;
                                 int x2 = graphPoints.get(i + 1).x;
                                 int y2 = graphPoints.get(i + 1).y;
                                 g2.drawLine(x1, y1, x2, y2);
                             }

                             g2.setStroke(oldStroke);
                             g2.setColor(pointColor);
                             for (int i = 0; i < graphPoints.size(); i++) {
                                 int x = graphPoints.get(i).x - pointWidth / 2;
                                 int y = graphPoints.get(i).y - pointWidth / 2;
                                 int ovalW = pointWidth;
                                 int ovalH = pointWidth;
                                 g2.fillOval(x, y, ovalW, ovalH);
                             }
                         }

                     //    @Override
                     //    public Dimension getPreferredSize() {
                     //        return new Dimension(width, heigth);
                     //    }
                         private double getMinScore() {
                             double minScore = Double.MAX_VALUE;
                             for (Double score : scores) {
                                 minScore = Math.min(minScore, score);
                             }
                             return minScore;
                         }

                         private double getMaxScore() {
                             double maxScore = Double.MIN_VALUE;
                             for (Double score : scores) {
                                 maxScore = Math.max(maxScore, score);
                             }
                             return maxScore;
                         }

                         public void setScores(List<Double> scores) {
                             this.scores = scores;
                             invalidate();
                             this.repaint();
                         }

                         public List<Double> getScores() {
                             return scores;
                         }

                         public static void createAndShowGui(ArrayList<Double> data, String titulo) {
                             DrawGraph mainPanel = new DrawGraph(data);
                             mainPanel.setPreferredSize(new Dimension(800, 600));
                             JFrame frame = new JFrame(titulo);
                             frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                             frame.getContentPane().add(mainPanel);
                             frame.pack();
                             frame.setLocationRelativeTo(null);
                             frame.setVisible(true);
                         }
                     }

ENTRENAMIENTO OR

                //        NeuralNetwork neuralNetwork = new Perceptron(2, 1);
                        NeuralNetwork neuralNetwork = 
                        new MultiLayerPerceptron(TransferFunctionType.STEP, 2, 2, 3, 3, 1);
                        // create training set
                        DataSet trainingSet = new DataSet(2, 1);
                        // add training data to training set (logical OR function)
                        trainingSet.addRow(new DataSetRow(new double[]{0, 0}, new double[]{0}));
                        trainingSet.addRow(new DataSetRow(new double[]{0, 1}, new double[]{1}));
                        trainingSet.addRow(new DataSetRow(new double[]{1, 0}, new double[]{1}));
                        trainingSet.addRow(new DataSetRow(new double[]{1, 1}, new double[]{1}));
                        // learn the training set
                        Long before = System.currentTimeMillis();
                        neuralNetwork.learn(trainingSet);
                        Long after = System.currentTimeMillis();
                        Long time = after-before;
                        System.err.println("Training= " + time + " milisegundos, " + time/1000 + " segundos.");
                        // save the trained network into file
                        neuralNetwork.save("or_perceptron.nnet");

                        try {
                            InputStream inputStream = new FileInputStream("or_perceptron.nnet");
                            NeuralNetwork neuralNetwork2 = NeuralNetwork.load(inputStream);

                            // set network input
                            neuralNetwork2.setInput(1, 0);
                            // calculate network
                            neuralNetwork2.calculate();
                            // get network output
                            double[] networkOutput = neuralNetwork2.getOutput();

                            for (Double d : networkOutput) {
                                System.out.println(d);
                            }
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                        }